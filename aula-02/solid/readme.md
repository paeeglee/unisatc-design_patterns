# Revisão de Conceitos - SOLID

## O que é SOLID

SOLID é um acrônimo que representa cinco princípios de design de software que ajudam a criar sistemas mais flexíveis, escaláveis e fáceis de manter. Cada letra do acrônimo representa um princípio fundamental:

  - **S - Single Responsibility Principle (Princípio da Responsabilidade Única)**: Este princípio estabelece que uma classe ou módulo deve ter apenas uma razão para mudar. Ou seja, uma classe deve ter apenas uma responsabilidade ou função bem definida. Isso ajuda a evitar que uma classe seja muito grande e complexa, tornando-a mais fácil de entender e manter.
  - **O - Open-Closed Principle (Princípio Aberto-Fechado)**: Este princípio estabelece que uma classe ou módulo deve ser aberto para extensão, mas fechado para modificação. Isso significa que você deve ser capaz de adicionar novas funcionalidades a uma classe sem precisar modificar seu código existente. Isso ajuda a manter a estabilidade do sistema e a evitar que mudanças em uma classe afetem outras partes do sistema.
  - **L - Liskov Substitution Principle (Princípio de Substituição de Liskov)**: Este princípio estabelece que objetos de uma classe derivada devem ser substituíveis por objetos de sua classe base. Isso significa que uma classe derivada deve ser capaz de ser usada como se fosse uma instância da classe base, sem que o código que a utiliza precise saber a diferença. Isso ajuda a garantir que as classes derivadas sejam compatíveis com as classes base.
  - **I - Interface Segregation Principle (Princípio de Segregação de Interface)**: Este princípio estabelece que uma classe não deve ser forçada a implementar interfaces que não são relevantes para ela. Em vez disso, as interfaces devem ser divididas em interfaces menores e mais específicas, que podem ser implementadas por classes que as necessitem. Isso ajuda a evitar que as classes sejam forçadas a implementar métodos que não são necessários.
  - **D - Dependency Inversion Principle (Princípio de Inversão de Dependência)**: Este princípio estabelece que as classes de alto nível não devem depender de classes de baixo nível, mas sim que ambas devem depender de abstrações. Isso significa que as classes devem ser projetadas para depender de interfaces ou abstrações, em vez de depender de implementações específicas. Isso ajuda a reduzir a dependência entre as classes e a tornar o sistema mais flexível e escalável.